#!/usr/bin/env python3
"""
SonicWall Firewall Migration Tool v1.0.0
==========================================
Migrates configuration from a source SonicWall firewall to a target firewall
using the SonicOS REST API.

Supports: Gen 6 (SonicOS 6.5.x), Gen 7 (SonicOS 7.x), Gen 8 (SonicOS 8.x)

Prerequisites:
  - SonicOS API must be enabled on BOTH firewalls
  - RFC-2617 HTTP Basic Access Authentication must be enabled
  - Admin credentials with full privileges
  - pip install requests

Usage:
  python3 sonicwall_migrator.py
  python3 sonicwall_migrator.py --config migration_config.json
  python3 sonicwall_migrator.py --export-only    (export source config to JSON)
  python3 sonicwall_migrator.py --import-only backup_20260219_120000.json

Author: Generated by Claude (Anthropic)
Date:   2026-02-19
"""

import requests
import json
import sys
import os
import time

__version__ = "1.0.0"
import logging
import argparse
import getpass
from datetime import datetime
from collections import OrderedDict
from typing import Optional

# ---------------------------------------------------------------------------
# Suppress insecure-request warnings (SonicWall typically uses self-signed certs)
# ---------------------------------------------------------------------------
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ---------------------------------------------------------------------------
# CLI Config Parser (for when API is disabled on source)
# ---------------------------------------------------------------------------
from cli_parser import CLIConfigParser

# ---------------------------------------------------------------------------
# Logging setup
# ---------------------------------------------------------------------------
LOG_DIR = "migration_logs"
os.makedirs(LOG_DIR, exist_ok=True)
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
log_file = os.path.join(LOG_DIR, f"migration_{timestamp}.log")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)-7s] %(message)s",
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler(sys.stdout),
    ],
)
logger = logging.getLogger("SonicWallMigrator")


# ============================================================================
# SonicWall API Client
# ============================================================================
class SonicWallAPI:
    """
    Unified client for the SonicOS REST API across Gen 6, 7, and 8.

    API Base Path:  https://<ip>:<port>/api/sonicos/
    Auth:           POST /api/sonicos/auth          (login)
                    DELETE /api/sonicos/auth         (logout)
    Commit:         POST /api/sonicos/config/pending (commit changes)

    The API structure is consistent across generations. Key differences:
      - Gen 6 (6.5.x):  API disabled by default; must enable in UI.
                         Some endpoints may lack newer fields.
      - Gen 7 (7.x):    API enabled by default. Full feature set.
      - Gen 8 (8.x):    API enabled by default. Same path structure as Gen 7.
                         Runs SonicOS 8.0+, some new fields for Gen 8 hardware.
    """

    # Standard headers required by SonicOS API (order matters for some firmware)
    HEADERS = OrderedDict([
        ("Accept", "application/json"),
        ("Content-Type", "application/json"),
        ("Accept-Encoding", "application/json"),
        ("Charset", "UTF-8"),
    ])

    def __init__(self, host: str, port: int, username: str, password: str,
                 label: str = "firewall", verify_ssl: bool = False):
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.label = label
        self.verify_ssl = verify_ssl
        self.base_url = f"https://{host}:{port}/api/sonicos"
        self.session = requests.Session()
        self.session.verify = verify_ssl
        self.session.auth = (username, password)
        self.session.headers.update(self.HEADERS)
        self.authenticated = False
        self.firmware_version = None
        self.generation = None
        self.model = None

    # ------------------------------------------------------------------
    # Authentication
    # ------------------------------------------------------------------
    def login(self) -> bool:
        """Authenticate to the SonicWall API."""
        logger.info(f"[{self.label}] Logging in to {self.host}:{self.port} ...")
        try:
            resp = self.session.post(f"{self.base_url}/auth", timeout=30)
            if resp.status_code == 200:
                self.authenticated = True
                logger.info(f"[{self.label}] Login successful.")
                self._detect_firmware()
                return True
            else:
                logger.error(f"[{self.label}] Login failed: HTTP {resp.status_code}")
                try:
                    logger.error(f"[{self.label}] Response: {resp.json()}")
                except Exception:
                    logger.error(f"[{self.label}] Response: {resp.text[:500]}")
                return False
        except requests.exceptions.ConnectionError as e:
            logger.error(f"[{self.label}] Connection failed: {e}")
            return False
        except Exception as e:
            logger.error(f"[{self.label}] Login error: {e}")
            return False

    def logout(self):
        """Logout from the SonicWall API."""
        if self.authenticated:
            try:
                self.session.delete(f"{self.base_url}/auth", timeout=15)
                logger.info(f"[{self.label}] Logged out.")
            except Exception:
                pass
            self.authenticated = False

    def _detect_firmware(self):
        """Detect firmware version and generation from the status endpoint."""
        try:
            resp = self._get("status")
            if resp and isinstance(resp, dict):
                # Try common response structures
                info = resp.get("status", resp)
                fw = (info.get("firmware_version") or
                      info.get("firmware") or
                      info.get("info", [{}])[0].get("firmware_version", ""))
                model = (info.get("model") or
                         info.get("product_model") or "Unknown")
                self.firmware_version = str(fw)
                self.model = str(model)
                self._classify_generation()
                logger.info(
                    f"[{self.label}] Detected: Model={self.model}, "
                    f"Firmware={self.firmware_version}, Gen={self.generation}"
                )
        except Exception:
            logger.warning(f"[{self.label}] Could not auto-detect firmware version.")

    def _classify_generation(self):
        """Classify the generation from the firmware version string."""
        fw = self.firmware_version or ""
        if fw.startswith("8.") or "8.0" in fw:
            self.generation = "Gen8"
        elif fw.startswith("7.") or "7.0" in fw or "7.1" in fw:
            self.generation = "Gen7"
        elif fw.startswith("6.") or "6.5" in fw:
            self.generation = "Gen6"
        else:
            self.generation = "Unknown"

    # ------------------------------------------------------------------
    # Core HTTP helpers
    # ------------------------------------------------------------------
    def _get(self, endpoint: str, params: dict = None) -> Optional[dict]:
        """GET request to SonicOS API."""
        url = f"{self.base_url}/{endpoint}"
        try:
            resp = self.session.get(url, params=params, timeout=60)
            if resp.status_code == 200:
                return resp.json()
            elif resp.status_code == 204:
                return {}
            else:
                logger.debug(f"[{self.label}] GET {endpoint} => HTTP {resp.status_code}")
                return None
        except json.JSONDecodeError:
            return None
        except Exception as e:
            logger.debug(f"[{self.label}] GET {endpoint} error: {e}")
            return None

    def _post(self, endpoint: str, data: dict) -> tuple:
        """POST request. Returns (success: bool, response_data: dict)."""
        url = f"{self.base_url}/{endpoint}"
        try:
            resp = self.session.post(url, json=data, timeout=60)
            try:
                body = resp.json()
            except Exception:
                body = {"raw": resp.text[:500]}
            success = resp.status_code in (200, 201)
            return success, body
        except Exception as e:
            return False, {"error": str(e)}

    def _put(self, endpoint: str, data: dict) -> tuple:
        """PUT request. Returns (success: bool, response_data: dict)."""
        url = f"{self.base_url}/{endpoint}"
        try:
            resp = self.session.put(url, json=data, timeout=60)
            try:
                body = resp.json()
            except Exception:
                body = {"raw": resp.text[:500]}
            success = resp.status_code in (200, 201)
            return success, body
        except Exception as e:
            return False, {"error": str(e)}

    def commit(self) -> bool:
        """Commit pending configuration changes."""
        logger.info(f"[{self.label}] Committing pending changes ...")
        url = f"{self.base_url}/config/pending"
        try:
            resp = self.session.post(url, timeout=60)
            if resp.status_code == 200:
                logger.info(f"[{self.label}] Commit successful.")
                return True
            else:
                logger.warning(f"[{self.label}] Commit returned HTTP {resp.status_code}")
                return False
        except Exception as e:
            logger.error(f"[{self.label}] Commit error: {e}")
            return False

    # ------------------------------------------------------------------
    # Interface & VLAN discovery
    # ------------------------------------------------------------------
    def get_interfaces(self) -> list:
        """
        Retrieve all interfaces from the firewall.
        Returns a list of interface dicts with name, zone, ip, etc.
        Tries multiple API endpoints since the structure varies by generation.
        """
        interfaces = []

        # Try the standard interfaces endpoint
        for endpoint in ["interfaces/ipv4", "interfaces"]:
            resp = self._get(endpoint)
            if resp:
                # The response may nest under various keys
                items = (resp.get("interfaces", []) or
                         resp.get("interface", []))
                if isinstance(items, dict):
                    # Sometimes a single interface is returned as dict
                    items = [items]
                if isinstance(items, list) and items:
                    # Flatten nested ipv4/ipv6 wrappers if present
                    for item in items:
                        if isinstance(item, dict):
                            # Handle {"ipv4": {...}} wrapper
                            if "ipv4" in item and isinstance(item["ipv4"], dict):
                                iface = item["ipv4"]
                                iface["_ip_version"] = "ipv4"
                                interfaces.append(iface)
                            elif "ipv6" in item and isinstance(item["ipv6"], dict):
                                iface = item["ipv6"]
                                iface["_ip_version"] = "ipv6"
                                interfaces.append(iface)
                            else:
                                interfaces.append(item)
                    break  # Got results, don't try other endpoints

        if interfaces:
            logger.info(f"[{self.label}] Found {len(interfaces)} interfaces")
        else:
            logger.warning(f"[{self.label}] Could not retrieve interfaces via API")

        return interfaces

    def get_vlans(self) -> list:
        """
        Retrieve all VLAN sub-interfaces.
        VLANs appear as sub-interfaces like X0:V10, X2:V100, etc.
        """
        vlans = []
        for endpoint in ["vlans", "interfaces/vlan"]:
            resp = self._get(endpoint)
            if resp:
                items = (resp.get("vlans", []) or
                         resp.get("vlan", []) or
                         resp.get("interfaces", []))
                if isinstance(items, dict):
                    items = [items]
                if isinstance(items, list) and items:
                    vlans = items
                    break

        # If dedicated VLAN endpoint didn't work, extract VLANs from interfaces
        if not vlans:
            all_ifaces = self.get_interfaces() if not vlans else []
            for iface in all_ifaces:
                name = iface.get("name", "")
                # VLAN sub-interfaces contain ":V" or ".V" in their name
                if ":V" in name.upper() or ".V" in name.upper() or "VLAN" in name.upper():
                    vlans.append(iface)

        if vlans:
            logger.info(f"[{self.label}] Found {len(vlans)} VLAN sub-interfaces")
        else:
            logger.info(f"[{self.label}] No VLAN sub-interfaces found")

        return vlans

    def get_interface_summary(self) -> dict:
        """
        Build a structured summary of all interfaces and their VLANs.
        Returns: {
            "physical": [{"name": "X0", "zone": "LAN", "ip": "...", ...}, ...],
            "vlans": {"X0": [{"vlan_id": 10, ...}, ...], "X2": [...], ...},
            "total_physical": 8,
            "total_vlans": 5,
        }
        """
        interfaces = self.get_interfaces()
        vlans = self.get_vlans()

        physical = []
        vlan_map = {}  # parent_interface -> [vlan_configs]

        for iface in interfaces:
            name = iface.get("name", "")
            # Physical interfaces are X0, X1, X2, etc. (no colon/dot)
            if name and not any(sep in name for sep in [":", "."]):
                ip = (iface.get("ip", {}).get("ip", "") if isinstance(iface.get("ip"), dict)
                      else iface.get("ip", ""))
                mask = (iface.get("ip", {}).get("mask", "") if isinstance(iface.get("ip"), dict)
                        else iface.get("mask", ""))
                zone = iface.get("zone", "")
                physical.append({
                    "name": name,
                    "zone": zone,
                    "ip": ip,
                    "mask": mask,
                    "management": iface.get("management", ""),
                    "comment": iface.get("comment", ""),
                    "enabled": iface.get("enabled", True),
                    "_raw": iface,
                })

        # Map VLANs to their parent interface
        all_vlan_items = vlans if vlans else []
        # Also check interfaces list for VLAN sub-interfaces
        for iface in interfaces:
            name = iface.get("name", "")
            if any(sep in name for sep in [":", "."]):
                all_vlan_items.append(iface)

        for vlan in all_vlan_items:
            name = vlan.get("name", "")
            # Parse parent interface: "X0:V10" -> parent="X0", vlan_tag=10
            parent = ""
            vlan_tag = ""
            for sep in [":", "."]:
                if sep in name:
                    parts = name.split(sep, 1)
                    parent = parts[0]
                    vlan_tag = parts[1].replace("V", "").replace("v", "") if len(parts) > 1 else ""
                    break

            if not parent:
                # Try VLAN-specific fields
                parent = vlan.get("parent_interface", vlan.get("interface", ""))
                vlan_tag = str(vlan.get("vlan_id", vlan.get("tag", "")))

            if parent:
                if parent not in vlan_map:
                    vlan_map[parent] = []

                ip = (vlan.get("ip", {}).get("ip", "") if isinstance(vlan.get("ip"), dict)
                      else vlan.get("ip", ""))
                zone = vlan.get("zone", "")

                vlan_map[parent].append({
                    "name": name,
                    "vlan_tag": vlan_tag,
                    "parent": parent,
                    "zone": zone,
                    "ip": ip,
                    "comment": vlan.get("comment", ""),
                    "_raw": vlan,
                })

        total_vlans = sum(len(v) for v in vlan_map.values())

        return {
            "physical": sorted(physical, key=lambda x: x["name"]),
            "vlans": vlan_map,
            "total_physical": len(physical),
            "total_vlans": total_vlans,
        }


# ============================================================================
# Configuration Resource Definitions
# ============================================================================
# Each resource defines:
#   - endpoint:    API path (appended to /api/sonicos/)
#   - key:         JSON root key in responses
#   - post_key:    JSON root key for POST body (if different from key)
#   - skip_default: If True, skip objects with "default" or built-in markers
#   - depends_on:  List of resource names that must be migrated first

MIGRATION_RESOURCES = [
    # ---- Network Objects (foundations, migrate first) ----
    {
        "name": "Zones",
        "endpoint_get": "zones",
        "endpoint_post": "zones",
        "key": "zones",
        "item_key": "zone",
        "skip_defaults": True,
        "depends_on": [],
        "description": "Security zones (LAN, WAN, DMZ, custom zones)",
    },
    {
        "name": "Address Objects (IPv4)",
        "endpoint_get": "address-objects/ipv4",
        "endpoint_post": "address-objects/ipv4",
        "key": "address_objects",
        "item_key": "address_object",
        "sub_key": "ipv4",
        "skip_defaults": True,
        "depends_on": ["Zones"],
        "description": "IPv4 host, range, network, and FQDN address objects",
    },
    {
        "name": "Address Objects (IPv6)",
        "endpoint_get": "address-objects/ipv6",
        "endpoint_post": "address-objects/ipv6",
        "key": "address_objects",
        "item_key": "address_object",
        "sub_key": "ipv6",
        "skip_defaults": True,
        "depends_on": ["Zones"],
        "description": "IPv6 address objects",
    },
    {
        "name": "Address Objects (FQDN)",
        "endpoint_get": "address-objects/fqdn",
        "endpoint_post": "address-objects/fqdn",
        "key": "address_objects",
        "item_key": "address_object",
        "sub_key": "fqdn",
        "skip_defaults": True,
        "depends_on": ["Zones"],
        "description": "FQDN-based address objects",
    },
    {
        "name": "Address Objects (MAC)",
        "endpoint_get": "address-objects/mac",
        "endpoint_post": "address-objects/mac",
        "key": "address_objects",
        "item_key": "address_object",
        "sub_key": "mac",
        "skip_defaults": True,
        "depends_on": ["Zones"],
        "description": "MAC-based address objects",
    },
    {
        "name": "Address Groups (IPv4)",
        "endpoint_get": "address-groups/ipv4",
        "endpoint_post": "address-groups/ipv4",
        "key": "address_groups",
        "item_key": "address_group",
        "sub_key": "ipv4",
        "skip_defaults": True,
        "depends_on": ["Address Objects (IPv4)"],
        "description": "IPv4 address object groups",
    },
    {
        "name": "Address Groups (IPv6)",
        "endpoint_get": "address-groups/ipv6",
        "endpoint_post": "address-groups/ipv6",
        "key": "address_groups",
        "item_key": "address_group",
        "sub_key": "ipv6",
        "skip_defaults": True,
        "depends_on": ["Address Objects (IPv6)"],
        "description": "IPv6 address object groups",
    },
    # ---- Service Objects ----
    {
        "name": "Service Objects",
        "endpoint_get": "service-objects",
        "endpoint_post": "service-objects",
        "key": "service_objects",
        "item_key": "service_object",
        "skip_defaults": True,
        "depends_on": [],
        "description": "Custom service objects (TCP/UDP/IP protocol definitions)",
    },
    {
        "name": "Service Groups",
        "endpoint_get": "service-groups",
        "endpoint_post": "service-groups",
        "key": "service_groups",
        "item_key": "service_group",
        "skip_defaults": True,
        "depends_on": ["Service Objects"],
        "description": "Service object groups",
    },
    # ---- Schedule Objects ----
    {
        "name": "Schedule Objects",
        "endpoint_get": "schedule-objects",
        "endpoint_post": "schedule-objects",
        "key": "schedule_objects",
        "item_key": "schedule_object",
        "skip_defaults": True,
        "depends_on": [],
        "description": "Time-based schedule objects",
    },
    {
        "name": "Schedule Groups",
        "endpoint_get": "schedule-groups",
        "endpoint_post": "schedule-groups",
        "key": "schedule_groups",
        "item_key": "schedule_group",
        "skip_defaults": True,
        "depends_on": ["Schedule Objects"],
        "description": "Schedule object groups",
    },
    # ---- Network Configuration ----
    {
        "name": "Route Policies (IPv4)",
        "endpoint_get": "route-policies/ipv4",
        "endpoint_post": "route-policies/ipv4",
        "key": "route_policies",
        "item_key": "route_policy",
        "sub_key": "ipv4",
        "skip_defaults": True,
        "depends_on": ["Zones", "Address Objects (IPv4)"],
        "description": "IPv4 static and policy-based routes",
    },
    {
        "name": "Route Policies (IPv6)",
        "endpoint_get": "route-policies/ipv6",
        "endpoint_post": "route-policies/ipv6",
        "key": "route_policies",
        "item_key": "route_policy",
        "sub_key": "ipv6",
        "skip_defaults": True,
        "depends_on": ["Zones", "Address Objects (IPv6)"],
        "description": "IPv6 static and policy-based routes",
    },
    # ---- Firewall Policies ----
    {
        "name": "NAT Policies (IPv4)",
        "endpoint_get": "nat-policies/ipv4",
        "endpoint_post": "nat-policies/ipv4",
        "key": "nat_policies",
        "item_key": "nat_policy",
        "sub_key": "ipv4",
        "skip_defaults": True,
        "depends_on": ["Address Objects (IPv4)", "Service Objects", "Zones"],
        "description": "IPv4 NAT translation policies",
    },
    {
        "name": "NAT Policies (IPv6)",
        "endpoint_get": "nat-policies/ipv6",
        "endpoint_post": "nat-policies/ipv6",
        "key": "nat_policies",
        "item_key": "nat_policy",
        "sub_key": "ipv6",
        "skip_defaults": True,
        "depends_on": ["Address Objects (IPv6)", "Service Objects", "Zones"],
        "description": "IPv6 NAT translation policies",
    },
    {
        "name": "Access Rules (IPv4)",
        "endpoint_get": "access-rules/ipv4",
        "endpoint_post": "access-rules/ipv4",
        "key": "access_rules",
        "item_key": "access_rule",
        "sub_key": "ipv4",
        "skip_defaults": True,
        "depends_on": [
            "Zones", "Address Objects (IPv4)", "Address Groups (IPv4)",
            "Service Objects", "Service Groups", "Schedule Objects",
        ],
        "description": "IPv4 firewall access rules",
    },
    {
        "name": "Access Rules (IPv6)",
        "endpoint_get": "access-rules/ipv6",
        "endpoint_post": "access-rules/ipv6",
        "key": "access_rules",
        "item_key": "access_rule",
        "sub_key": "ipv6",
        "skip_defaults": True,
        "depends_on": [
            "Zones", "Address Objects (IPv6)", "Address Groups (IPv6)",
            "Service Objects", "Service Groups",
        ],
        "description": "IPv6 firewall access rules",
    },
    # ---- VPN ----
    {
        "name": "VPN Policies (Site-to-Site)",
        "endpoint_get": "vpn/policies/ipv4",
        "endpoint_post": "vpn/policies/ipv4",
        "key": "vpn",
        "item_key": "vpn_policy",
        "skip_defaults": True,
        "depends_on": ["Address Objects (IPv4)", "Address Groups (IPv4)"],
        "description": "Site-to-site VPN policies (IPv4)",
    },
    # ---- Content Filter ----
    {
        "name": "Content Filter Profiles",
        "endpoint_get": "content-filter/profiles",
        "endpoint_post": "content-filter/profiles",
        "key": "content_filter_profiles",
        "item_key": "content_filter_profile",
        "skip_defaults": True,
        "depends_on": [],
        "description": "Content filtering profiles and policies",
    },
    # ---- Users and Groups ----
    {
        "name": "User Local Groups",
        "endpoint_get": "user/local/groups",
        "endpoint_post": "user/local/groups",
        "key": "user_local_groups",
        "item_key": "user_local_group",
        "skip_defaults": True,
        "depends_on": [],
        "description": "Local user groups",
    },
    {
        "name": "User Local",
        "endpoint_get": "user/local",
        "endpoint_post": "user/local",
        "key": "users_local",
        "item_key": "user_local",
        "skip_defaults": True,
        "depends_on": ["User Local Groups"],
        "description": "Local user accounts",
    },
]

# Built-in / default object names that should NOT be migrated
DEFAULT_OBJECT_PREFIXES = [
    # NOTE: Intentionally conservative. Only skip objects that are guaranteed
    # to exist on any SonicWall. Interface-specific objects (X0 IP, X1 Subnet)
    # are NOT skipped because they hold user-configured IPs/subnets that
    # likely differ on the target. They will fail gracefully if they already
    # exist (POST → PUT fallback).
]

# Names of objects that are always auto-created on every SonicWall and
# cannot/should not be overwritten.
DEFAULT_OBJECT_EXACT_NAMES = {
    # These are universal built-in objects on every SonicWall
    "Any",
    "any",
}

DEFAULT_ZONE_NAMES = {
    "LAN", "WAN", "DMZ", "VPN", "SSLVPN", "WLAN", "MGMT",
    "Multicast", "MULTICAST", "RADIUS",
}


# ============================================================================
# Migration Engine
# ============================================================================
class SonicWallMigrator:
    """Orchestrates the export from source and import to target."""

    def __init__(self, source: SonicWallAPI, target: SonicWallAPI = None,
                 dry_run: bool = False, skip_resources: list = None):
        self.source = source
        self.target = target
        self.dry_run = dry_run
        self.skip_resources = skip_resources or []
        self.exported_config = {}
        self.stats = {
            "exported": {},
            "imported": {},
            "skipped": {},
            "errors": {},
        }

    # ------------------------------------------------------------------
    # Filtering helpers
    # ------------------------------------------------------------------
    @staticmethod
    def _is_default_object(item: dict, resource_name: str) -> bool:
        """
        Heuristic to detect built-in/default objects that shouldn't be migrated.

        NOTE: Gen 8 (SonicOS 8.x) uses '00000000-' UUID prefixes even for
        user-created objects, so we do NOT filter by UUID.
        """
        name = ""

        # Try to extract name from nested structures
        if isinstance(item, dict):
            name = (item.get("name", "") or
                    item.get("ipv4", {}).get("name", "") or
                    item.get("ipv6", {}).get("name", "") or
                    item.get("fqdn", {}).get("name", "") or
                    item.get("mac", {}).get("name", "") or "")

        if not name:
            return False

        # Zone defaults — skip built-in zones
        if "Zone" in resource_name and name in DEFAULT_ZONE_NAMES:
            return True

        # Exact name matches — only truly universal built-ins
        if name in DEFAULT_OBJECT_EXACT_NAMES:
            return True

        # Skip objects explicitly flagged as not editable by the API
        if item.get("not_editable") is True:
            return True

        return False

    @staticmethod
    def _clean_item_for_import(item: dict) -> dict:
        """
        Remove read-only / source-specific fields before importing.
        UUIDs are regenerated by the target. Statistics fields are irrelevant.
        """
        keys_to_remove = [
            "uuid", "statistics", "hit_count", "id", "index",
            "not_editable", "default", "readonly",
        ]
        cleaned = {}
        for k, v in item.items():
            if k in keys_to_remove:
                continue
            if isinstance(v, dict):
                v = SonicWallMigrator._clean_item_for_import(v)
            cleaned[k] = v
        return cleaned

    # ------------------------------------------------------------------
    # Interface & VLAN migration
    # ------------------------------------------------------------------
    def compare_interfaces(self) -> dict:
        """
        Compare interfaces between source and target firewalls.
        Returns a dict with comparison results and compatibility info.
        """
        logger.info("=" * 70)
        logger.info("INTERFACE HARDWARE COMPARISON")
        logger.info("=" * 70)

        src_summary = self.source.get_interface_summary()
        tgt_summary = self.target.get_interface_summary()

        src_phys = src_summary["physical"]
        tgt_phys = tgt_summary["physical"]
        src_vlans = src_summary["vlans"]
        tgt_names = {i["name"] for i in tgt_phys}

        # Display source hardware
        logger.info("")
        logger.info(f"  SOURCE ({self.source.model} - {self.source.generation}):")
        logger.info(f"    Physical interfaces: {src_summary['total_physical']}")
        logger.info(f"    VLAN sub-interfaces: {src_summary['total_vlans']}")
        for iface in src_phys:
            vlan_count = len(src_vlans.get(iface["name"], []))
            vlan_str = f" ({vlan_count} VLANs)" if vlan_count else ""
            ip_str = f" [{iface['ip']}]" if iface.get("ip") else ""
            zone_str = f" Zone: {iface['zone']}" if iface.get("zone") else ""
            logger.info(f"      {iface['name']:<6}{zone_str}{ip_str}{vlan_str}")

        # Display target hardware
        logger.info("")
        logger.info(f"  TARGET ({self.target.model} - {self.target.generation}):")
        logger.info(f"    Physical interfaces: {tgt_summary['total_physical']}")
        logger.info(f"    VLAN sub-interfaces: {tgt_summary['total_vlans']}")
        for iface in tgt_phys:
            tgt_vlans_on = tgt_summary["vlans"].get(iface["name"], [])
            vlan_count = len(tgt_vlans_on)
            vlan_str = f" ({vlan_count} VLANs)" if vlan_count else ""
            ip_str = f" [{iface['ip']}]" if iface.get("ip") else ""
            zone_str = f" Zone: {iface['zone']}" if iface.get("zone") else ""
            logger.info(f"      {iface['name']:<6}{zone_str}{ip_str}{vlan_str}")

        # Check compatibility
        source_only = [i for i in src_phys if i["name"] not in tgt_names]
        has_more = len(src_phys) > len(tgt_phys)

        if source_only:
            logger.info("")
            logger.warning(
                f"  *** SOURCE has {len(source_only)} interfaces NOT available "
                f"on TARGET: {', '.join(i['name'] for i in source_only)}"
            )

        # X0 safety exclusion
        logger.info("")
        logger.info("  *** X0 is EXCLUDED from migration (safety) ***")
        logger.info("  X0 is your primary LAN/management interface and must be")
        logger.info("  configured manually when the new firewall is installed live.")

        return {
            "source": src_summary,
            "target": tgt_summary,
            "source_only_interfaces": source_only,
            "source_has_more": has_more,
            "compatible": not has_more,
        }

    def select_interfaces_interactive(self, comparison: dict) -> dict:
        """
        Interactive interface/VLAN selection when source has more interfaces
        than target. X0 is always excluded for safety (must be configured
        manually when the new firewall goes live).
        Returns a mapping dict:
        {
            "interfaces": [list of source interface configs to migrate],
            "vlans": [list of source VLAN configs to migrate],
            "mapping": {"X2": "X2", "X3": "X1", ...}  (source->target)
        }
        """
        # X0 is always excluded — it's the primary LAN/management interface
        # and must be configured manually when the target goes into production.
        EXCLUDED_INTERFACES = {"X0"}

        src_summary = comparison["source"]
        tgt_summary = comparison["target"]
        src_phys = src_summary["physical"]
        tgt_phys = tgt_summary["physical"]
        src_vlans = src_summary["vlans"]
        tgt_names = [i["name"] for i in tgt_phys]

        # Filter out X0 from source list
        src_phys_filtered = [i for i in src_phys if i["name"] not in EXCLUDED_INTERFACES]
        x0_vlans = len(src_vlans.get("X0", []))
        if x0_vlans:
            logger.info(f"    X0 has {x0_vlans} VLANs — these are also excluded.")
            logger.info(f"    You must recreate X0 VLANs manually on the target.")

        # Also exclude X0 from available target list (don't let anyone map TO X0)
        tgt_names_available = [n for n in tgt_names if n not in EXCLUDED_INTERFACES]

        result = {
            "interfaces": [],
            "vlans": [],
            "mapping": {},
        }

        # Recalculate whether source has more (excluding X0 on both sides)
        tgt_phys_count = len([i for i in tgt_phys if i["name"] not in EXCLUDED_INTERFACES])
        source_has_more = len(src_phys_filtered) > tgt_phys_count

        if source_has_more:
            print(f"\n{'!' * 70}")
            print(f"  SOURCE has MORE interfaces ({len(src_phys_filtered)} excl. X0) "
                  f"than TARGET ({tgt_phys_count} excl. X0).")
            print(f"  You must select which source interfaces to migrate")
            print(f"  and map them to available target interfaces.")
            print(f"{'!' * 70}")

            print(f"\n  Available TARGET interfaces (excl. X0): "
                  f"{', '.join(tgt_names_available)}")
            print()

            # Let user select and map each source interface
            print("  For each source interface, select the target interface to map to.")
            print("  Enter 'skip' to skip an interface, or 'done' when finished.\n")

            used_targets = set()

            for src_iface in src_phys_filtered:
                src_name = src_iface["name"]
                vlan_count = len(src_vlans.get(src_name, []))
                vlan_str = f" + {vlan_count} VLANs" if vlan_count else ""
                ip_str = f" [{src_iface['ip']}]" if src_iface.get("ip") else ""
                zone_str = f" (Zone: {src_iface['zone']})" if src_iface.get("zone") else ""

                available = [t for t in tgt_names_available if t not in used_targets]
                if not available:
                    logger.warning(f"    No more target interfaces available. "
                                   f"Skipping {src_name} and remaining.")
                    break

                print(f"  Source: {src_name}{zone_str}{ip_str}{vlan_str}")
                print(f"    Available targets: {', '.join(available)}")
                choice = input(f"    Map {src_name} to [skip]: ").strip()

                if choice.lower() in ("skip", "s", ""):
                    logger.info(f"    Skipping interface {src_name}")
                    continue
                elif choice.lower() == "done":
                    break
                elif choice in available:
                    result["mapping"][src_name] = choice
                    result["interfaces"].append(src_iface)
                    used_targets.add(choice)
                    logger.info(f"    Mapped: {src_name} -> {choice}")

                    # Include VLANs for this interface
                    iface_vlans = src_vlans.get(src_name, [])
                    if iface_vlans:
                        print(f"\n    VLANs on {src_name}:")
                        for i, vlan in enumerate(iface_vlans, 1):
                            vz = f" Zone: {vlan['zone']}" if vlan.get("zone") else ""
                            vi = f" [{vlan['ip']}]" if vlan.get("ip") else ""
                            print(f"      {i}. {vlan['name']}{vz}{vi}")

                        vlan_choice = input(
                            f"    Migrate VLANs? [all/none/comma-separated numbers]: "
                        ).strip().lower()

                        if vlan_choice in ("all", "a", ""):
                            for vlan in iface_vlans:
                                vlan["_target_parent"] = choice
                            result["vlans"].extend(iface_vlans)
                            logger.info(f"    Including all {len(iface_vlans)} VLANs")
                        elif vlan_choice not in ("none", "n"):
                            try:
                                indices = [int(x.strip()) for x in vlan_choice.split(",")]
                                for idx in indices:
                                    if 1 <= idx <= len(iface_vlans):
                                        vlan = iface_vlans[idx - 1]
                                        vlan["_target_parent"] = choice
                                        result["vlans"].append(vlan)
                                logger.info(f"    Including {len(indices)} selected VLANs")
                            except ValueError:
                                logger.warning("    Invalid selection — skipping VLANs")
                    print()
                else:
                    logger.warning(f"    Invalid target '{choice}' — skipping {src_name}")

        else:
            # Target has same or more interfaces — straightforward 1:1 mapping
            print("\n  Interfaces are compatible (target has enough ports, excl. X0).")
            print("  Select which source interfaces to migrate:\n")

            for i, src_iface in enumerate(src_phys_filtered, 1):
                src_name = src_iface["name"]
                vlan_count = len(src_vlans.get(src_name, []))
                vlan_str = f" + {vlan_count} VLANs" if vlan_count else ""
                ip_str = f" [{src_iface['ip']}]" if src_iface.get("ip") else ""
                zone_str = f" (Zone: {src_iface['zone']})" if src_iface.get("zone") else ""
                print(f"    {i}. {src_name}{zone_str}{ip_str}{vlan_str}")

            selection = input(
                "\n  Enter interface numbers to migrate "
                "(comma-separated, 'all', or 'none'): "
            ).strip().lower()

            selected_ifaces = []
            if selection in ("all", "a"):
                selected_ifaces = list(range(len(src_phys_filtered)))
            elif selection not in ("none", "n", ""):
                try:
                    selected_ifaces = [int(x.strip()) - 1 for x in selection.split(",")]
                except ValueError:
                    logger.warning("Invalid selection — skipping interfaces.")

            for idx in selected_ifaces:
                if 0 <= idx < len(src_phys_filtered):
                    src_iface = src_phys_filtered[idx]
                    src_name = src_iface["name"]
                    # Map to same interface name on target (1:1)
                    if src_name in tgt_names_available:
                        result["mapping"][src_name] = src_name
                        result["interfaces"].append(src_iface)
                        # Include all VLANs for selected interfaces
                        iface_vlans = src_vlans.get(src_name, [])
                        for vlan in iface_vlans:
                            vlan["_target_parent"] = src_name
                        result["vlans"].extend(iface_vlans)
                    else:
                        logger.warning(
                            f"    {src_name} not available on target — skipping"
                        )

        # Summary
        logger.info("")
        logger.info("  Interface migration plan:")
        logger.info("    X0: EXCLUDED (configure manually when firewall goes live)")
        if result["interfaces"]:
            for src_name, tgt_name in result["mapping"].items():
                arrow = f"{src_name} -> {tgt_name}"
                vlan_count = len([v for v in result["vlans"]
                                  if v.get("_target_parent") == tgt_name])
                vs = f" + {vlan_count} VLANs" if vlan_count else ""
                logger.info(f"    {arrow}{vs}")
        else:
            logger.info("    No other interfaces selected for migration.")

        return result

    def migrate_interfaces(self, interface_plan: dict):
        """
        Apply the interface migration plan to the target firewall.
        Configures interface IP settings, zones, and VLAN sub-interfaces.
        """
        if not interface_plan["interfaces"] and not interface_plan["vlans"]:
            logger.info("  No interfaces to migrate.")
            return

        logger.info("=" * 70)
        logger.info("MIGRATING INTERFACES & VLANs")
        logger.info("=" * 70)

        mapping = interface_plan["mapping"]
        successes = 0
        errors = 0

        # --- Migrate physical interface settings ---
        for src_iface in interface_plan["interfaces"]:
            src_name = src_iface["name"]
            tgt_name = mapping.get(src_name, src_name)
            raw = src_iface.get("_raw", src_iface)

            # Clean the config for import
            cleaned = self._clean_item_for_import(raw)

            # Remap interface name if different
            if src_name != tgt_name:
                cleaned["name"] = tgt_name
                logger.info(f"    Remapping {src_name} -> {tgt_name}")

            # Build PUT body (interfaces are updated, not created)
            body = {"interface": {"ipv4": cleaned}}

            item_label = (f"{src_name}->{tgt_name}" if src_name != tgt_name
                          else tgt_name)

            if self.dry_run:
                logger.info(f"    [DRY RUN] Would configure: {item_label}")
                successes += 1
                continue

            # Use PUT since interfaces already exist on the target
            ok, resp = self.target._put(f"interfaces/ipv4", body)
            if ok:
                successes += 1
                logger.info(f"    Configured: {item_label}")
            else:
                errors += 1
                msg = ""
                status = resp.get("status", {})
                for info in status.get("info", []):
                    msg += info.get("message", "")
                logger.warning(f"    FAILED: {item_label} — {msg}")

        # Commit interfaces before VLANs (VLANs depend on parent config)
        if successes > 0 and not self.dry_run:
            self.target.commit()
            time.sleep(2)

        # --- Migrate VLAN sub-interfaces ---
        vlan_successes = 0
        vlan_errors = 0

        for vlan in interface_plan["vlans"]:
            tgt_parent = vlan.get("_target_parent", "")
            raw = vlan.get("_raw", vlan)
            cleaned = self._clean_item_for_import(raw)

            # Remap parent interface in VLAN name if needed
            src_parent = vlan.get("parent", "")
            if src_parent and tgt_parent and src_parent != tgt_parent:
                old_name = cleaned.get("name", "")
                new_name = old_name.replace(src_parent, tgt_parent)
                cleaned["name"] = new_name
                if "parent_interface" in cleaned:
                    cleaned["parent_interface"] = tgt_parent
                if "interface" in cleaned:
                    cleaned["interface"] = tgt_parent
                logger.info(f"    Remapping VLAN: {old_name} -> {new_name}")

            vlan_name = cleaned.get("name", str(vlan.get("vlan_tag", "unknown")))

            # Try POST first (create), fall back to PUT (update)
            body = {"interface": {"ipv4": cleaned}}

            if self.dry_run:
                logger.info(f"    [DRY RUN] Would create VLAN: {vlan_name}")
                vlan_successes += 1
                continue

            ok, resp = self.target._post("interfaces/ipv4", body)
            if ok:
                vlan_successes += 1
                logger.info(f"    Created VLAN: {vlan_name}")
            else:
                # Try PUT if it already exists
                ok2, resp2 = self.target._put("interfaces/ipv4", body)
                if ok2:
                    vlan_successes += 1
                    logger.info(f"    Updated VLAN: {vlan_name}")
                else:
                    vlan_errors += 1
                    msg = ""
                    status = resp2.get("status", {})
                    for info in status.get("info", []):
                        msg += info.get("message", "")
                    logger.warning(f"    FAILED VLAN: {vlan_name} — {msg}")

        if vlan_successes > 0 and not self.dry_run:
            self.target.commit()
            time.sleep(1)

        # Update stats
        total_s = successes + vlan_successes
        total_e = errors + vlan_errors
        self.stats["imported"]["Interfaces"] = successes
        self.stats["imported"]["VLANs"] = vlan_successes
        self.stats["errors"]["Interfaces"] = errors
        self.stats["errors"]["VLANs"] = vlan_errors

        logger.info(f"    Interfaces: {successes} ok, {errors} failed")
        logger.info(f"    VLANs:      {vlan_successes} ok, {vlan_errors} failed")

    # ------------------------------------------------------------------
    # Export
    # ------------------------------------------------------------------
    def export_all(self) -> dict:
        """Export all configuration resources from the source firewall."""
        logger.info("=" * 70)
        logger.info("PHASE 1: EXPORTING CONFIGURATION FROM SOURCE")
        logger.info("=" * 70)

        config = {
            "_metadata": {
                "exported_at": datetime.now().isoformat(),
                "source_host": self.source.host,
                "source_model": self.source.model,
                "source_firmware": self.source.firmware_version,
                "source_generation": self.source.generation,
            }
        }

        for resource in MIGRATION_RESOURCES:
            rname = resource["name"]
            if rname in self.skip_resources:
                logger.info(f"  SKIP (user request): {rname}")
                continue

            logger.info(f"  Exporting: {rname} ...")
            items = self._export_resource(resource)
            config[rname] = items
            count = len(items) if items else 0
            self.stats["exported"][rname] = count
            logger.info(f"    => {count} items exported")

        self.exported_config = config
        return config

    def _export_resource(self, resource: dict) -> list:
        """Export a single resource type from the source."""
        endpoint = resource["endpoint_get"]
        key = resource["key"]
        sub_key = resource.get("sub_key")
        skip_defaults = resource.get("skip_defaults", True)

        resp = self.source._get(endpoint)
        if not resp:
            logger.debug(f"    API returned None/empty for {endpoint}")
            return []

        # Log the top-level keys for debugging
        logger.debug(f"    API response keys for {endpoint}: {list(resp.keys())}")

        # Navigate the response JSON to find the items list
        items = resp.get(key, [])

        # Handle nested structures: some endpoints wrap items differently
        if isinstance(items, dict):
            logger.debug(f"    '{key}' is a dict with keys: {list(items.keys())}")
            if sub_key and sub_key in items:
                items = items[sub_key]
            else:
                items = [items]

        if not isinstance(items, list):
            items = [items] if items else []

        logger.debug(f"    Raw items found: {len(items)}")

        # Filter out default/built-in objects
        if skip_defaults:
            filtered = []
            skipped_count = 0
            for item in items:
                if self._is_default_object(item, resource["name"]):
                    skipped_count += 1
                    skipped_name = ""
                    if isinstance(item, dict):
                        skipped_name = (item.get("name", "") or
                                        item.get("ipv4", {}).get("name", "") or "")
                    logger.debug(f"    Skipped default: {skipped_name}")
                else:
                    filtered.append(item)
            if skipped_count:
                logger.debug(f"    Skipped {skipped_count} default/built-in objects")
            items = filtered

        return items

    # ------------------------------------------------------------------
    # Import
    # ------------------------------------------------------------------
    def import_all(self, config: dict = None):
        """Import all configuration resources to the target firewall."""
        if config is None:
            config = self.exported_config

        if not config:
            logger.error("No configuration data to import!")
            return

        logger.info("=" * 70)
        logger.info("PHASE 2: IMPORTING CONFIGURATION TO TARGET")
        logger.info("=" * 70)

        metadata = config.get("_metadata", {})
        if metadata:
            logger.info(f"  Source: {metadata.get('source_host')} "
                        f"({metadata.get('source_generation')}, "
                        f"FW: {metadata.get('source_firmware')})")
            logger.info(f"  Target: {self.target.host} "
                        f"({self.target.generation}, "
                        f"FW: {self.target.firmware_version})")

        # Detect cross-generation migration
        src_gen = metadata.get("source_generation", "")
        tgt_gen = self.target.generation or ""
        if src_gen != tgt_gen and src_gen and tgt_gen:
            logger.warning(
                f"  *** CROSS-GENERATION MIGRATION: {src_gen} -> {tgt_gen} ***"
            )
            logger.warning(
                "  Some fields may not be compatible. Errors will be logged."
            )

        for resource in MIGRATION_RESOURCES:
            rname = resource["name"]
            if rname in self.skip_resources:
                logger.info(f"  SKIP (user request): {rname}")
                continue

            items = config.get(rname, [])
            if not items:
                logger.info(f"  SKIP (no data): {rname}")
                continue

            logger.info(f"  Importing: {rname} ({len(items)} items) ...")
            success, errors = self._import_resource(resource, items)
            self.stats["imported"][rname] = success
            self.stats["errors"][rname] = errors

            if errors:
                logger.warning(f"    => {success} succeeded, {errors} failed")
            else:
                logger.info(f"    => {success} succeeded")

            # Commit after each resource group for safety
            if success > 0 and not self.dry_run:
                self.target.commit()
                time.sleep(1)  # Brief pause to let the firewall settle

    def _import_resource(self, resource: dict, items: list) -> tuple:
        """Import a list of items for a given resource. Returns (success_count, error_count)."""
        endpoint = resource["endpoint_post"]
        item_key = resource["item_key"]
        sub_key = resource.get("sub_key")
        successes = 0
        errors = 0

        for item in items:
            cleaned = self._clean_item_for_import(item)

            # Build the POST body according to SonicOS API conventions.
            # The API expects: {"address_object": {"ipv4": {"name": ..., ...}}}
            #
            # If the exported item already contains the sub_key wrapper
            # (e.g., {"ipv4": {"name": ...}}) — which happens when exporting
            # via the API — don't wrap again. If it's a flat dict (e.g., from
            # CLI parsing), wrap it.
            if sub_key:
                if sub_key in cleaned and isinstance(cleaned[sub_key], dict):
                    # Already wrapped: {"ipv4": {"name": ...}} -> use as-is
                    body = {item_key: cleaned}
                else:
                    # Flat dict: {"name": ...} -> wrap with sub_key
                    body = {item_key: {sub_key: cleaned}}
            else:
                body = {item_key: cleaned}

            # Extract name for logging
            if sub_key and sub_key in cleaned and isinstance(cleaned[sub_key], dict):
                item_name = cleaned[sub_key].get("name", str(cleaned)[:60])
            elif sub_key:
                item_name = cleaned.get("name", str(cleaned)[:60])
            else:
                item_name = cleaned.get("name", str(cleaned)[:60])

            if self.dry_run:
                logger.info(f"    [DRY RUN] Would create: {item_name}")
                successes += 1
                continue

            ok, resp = self.target._post(endpoint, body)
            if ok:
                successes += 1
                logger.debug(f"    Created: {item_name}")
            else:
                # Check if it already exists — try PUT to update instead
                status_info = resp.get("status", {})
                info_list = status_info.get("info", [])
                already_exists = any(
                    "already exists" in str(i.get("message", "")).lower() or
                    "E_EXISTS" in str(i.get("code", ""))
                    for i in info_list
                )

                if already_exists:
                    logger.debug(f"    Already exists, trying PUT: {item_name}")
                    ok2, resp2 = self.target._put(endpoint, body)
                    if ok2:
                        successes += 1
                        logger.debug(f"    Updated: {item_name}")
                    else:
                        errors += 1
                        logger.warning(f"    FAILED (update): {item_name}")
                        logger.debug(f"    Response: {json.dumps(resp2, indent=2)[:300]}")
                else:
                    errors += 1
                    msg = ""
                    for i in info_list:
                        msg += i.get("message", "")
                    logger.warning(f"    FAILED: {item_name} — {msg}")
                    logger.debug(f"    Body: {json.dumps(body, indent=2)[:300]}")

        return successes, errors

    # ------------------------------------------------------------------
    # Reporting
    # ------------------------------------------------------------------
    def print_summary(self):
        """Print migration summary."""
        logger.info("")
        logger.info("=" * 70)
        logger.info("MIGRATION SUMMARY")
        logger.info("=" * 70)
        logger.info(f"{'Resource':<35} {'Exported':>10} {'Imported':>10} {'Errors':>10}")
        logger.info("-" * 70)

        total_exp = total_imp = total_err = 0

        # Include interface/VLAN stats if present
        for extra in ["Interfaces", "VLANs"]:
            imp = self.stats["imported"].get(extra, 0)
            err = self.stats["errors"].get(extra, 0)
            exp = self.stats["exported"].get(extra, imp)  # export = import for ifaces
            if imp or err:
                total_exp += exp
                total_imp += imp
                total_err += err
                logger.info(f"  {extra:<33} {exp:>10} {imp:>10} {err:>10}")

        for resource in MIGRATION_RESOURCES:
            rname = resource["name"]
            exp = self.stats["exported"].get(rname, 0)
            imp = self.stats["imported"].get(rname, 0)
            err = self.stats["errors"].get(rname, 0)
            total_exp += exp
            total_imp += imp
            total_err += err
            if exp or imp or err:
                logger.info(f"  {rname:<33} {exp:>10} {imp:>10} {err:>10}")

        logger.info("-" * 70)
        logger.info(f"  {'TOTAL':<33} {total_exp:>10} {total_imp:>10} {total_err:>10}")
        logger.info("")
        logger.info(f"Full log saved to: {log_file}")


# ============================================================================
# Interactive Setup
# ============================================================================
def gather_firewall_info(label: str) -> dict:
    """Interactively gather connection details for a firewall."""
    print(f"\n--- {label} Firewall Details ---")
    host = input(f"  IP Address / Hostname: ").strip()
    port_str = input(f"  Management Port [443]: ").strip()
    port = int(port_str) if port_str else 443
    username = input(f"  Admin Username [admin]: ").strip() or "admin"
    password = getpass.getpass(f"  Admin Password: ")
    return {
        "host": host,
        "port": port,
        "username": username,
        "password": password,
    }


def select_resources() -> list:
    """Let the user choose which resources to skip."""
    print("\n--- Resource Selection ---")
    print("The following resources will be migrated:\n")
    for i, r in enumerate(MIGRATION_RESOURCES, 1):
        print(f"  {i:>2}. {r['name']:<35} — {r['description']}")
    print()
    skip_input = input(
        "Enter numbers to SKIP (comma-separated), or press Enter for all: "
    ).strip()

    skip_names = []
    if skip_input:
        try:
            indices = [int(x.strip()) for x in skip_input.split(",")]
            for idx in indices:
                if 1 <= idx <= len(MIGRATION_RESOURCES):
                    skip_names.append(MIGRATION_RESOURCES[idx - 1]["name"])
        except ValueError:
            logger.warning("Invalid input — migrating all resources.")
    return skip_names


# ============================================================================
# Main Entry Point
# ============================================================================
def main():
    parser = argparse.ArgumentParser(
        description="SonicWall Firewall Migration Tool (Gen 6/7/8)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 sonicwall_migrator.py                     # Interactive migration
  python3 sonicwall_migrator.py --export-only        # Export source to JSON
  python3 sonicwall_migrator.py --import-only FILE   # Import JSON to target
  python3 sonicwall_migrator.py --cli-import log.txt  # Parse CLI config as source
  python3 sonicwall_migrator.py --dry-run            # Simulate without changes
  python3 sonicwall_migrator.py --config config.json # Use saved config file

CLI Import Mode (when API is disabled on source):
  1. SSH into the source firewall
  2. Run: show current-config
  3. Save the full output to a text file (PuTTY log works perfectly)
  4. Run: python3 sonicwall_migrator.py --cli-import putty.log

Config JSON format:
  {
    "source": {"host": "10.0.0.1", "port": 443, "username": "admin", "password": "xxx"},
    "target": {"host": "10.0.0.2", "port": 443, "username": "admin", "password": "xxx"},
    "skip_resources": ["Content Filter Profiles"],
    "dry_run": false
  }
        """,
    )
    parser.add_argument("--config", help="Path to JSON config file")
    parser.add_argument("--export-only", action="store_true",
                        help="Export source config to JSON file only")
    parser.add_argument("--import-only", metavar="FILE",
                        help="Import from a previously exported JSON file")
    parser.add_argument("--dry-run", action="store_true",
                        help="Simulate migration without making changes")
    parser.add_argument("--cli-import", metavar="FILE",
                        help="Parse a 'show current-config' CLI log file as source "
                             "(use when API is disabled on source firewall)")
    parser.add_argument("--verbose", "-v", action="store_true",
                        help="Enable verbose/debug logging (shows API response details)")

    args = parser.parse_args()

    # Enable debug logging if verbose flag set
    if args.verbose:
        logger.setLevel(logging.DEBUG)
        logging.getLogger().setLevel(logging.DEBUG)
        logger.debug("Verbose/debug logging enabled")

    print("=" * 70)
    print(f"   SonicWall Firewall Migration Tool v{__version__}")
    print("   Supports Gen 6 (6.5.x) | Gen 7 (7.x) | Gen 8 (8.x)")
    print("=" * 70)
    print()
    print("  IMPORTANT PREREQUISITES:")
    print("  1. SonicOS API must be enabled on both firewalls")
    print("     (or use --cli-import for source with API disabled)")
    print("  2. Enable 'RFC-2617 HTTP Basic Access Authentication'")
    print("  3. Use an account with full admin privileges")
    print("  4. Only one admin session is allowed at a time")
    print()

    source_info = None
    target_info = None
    skip_resources = []
    dry_run = args.dry_run
    migrate_interfaces_flag = None  # None = ask, True/False = from config

    # Load from config file if provided
    if args.config:
        with open(args.config) as f:
            cfg = json.load(f)
        source_info = cfg.get("source")
        target_info = cfg.get("target")
        skip_resources = cfg.get("skip_resources", [])
        dry_run = cfg.get("dry_run", dry_run)
        migrate_interfaces_flag = cfg.get("migrate_interfaces")

    # ---- IMPORT-ONLY MODE ----
    if args.import_only:
        logger.info(f"Import-only mode: loading {args.import_only}")
        with open(args.import_only) as f:
            config = json.load(f)

        if not target_info:
            target_info = gather_firewall_info("TARGET")
        if not skip_resources:
            skip_resources = select_resources()

        target = SonicWallAPI(**target_info, label="TARGET")
        if not target.login():
            logger.error("Cannot connect to target firewall. Aborting.")
            sys.exit(1)

        try:
            migrator = SonicWallMigrator(
                source=None, target=target,
                dry_run=dry_run, skip_resources=skip_resources,
            )
            migrator.import_all(config)
            migrator.print_summary()
        finally:
            target.logout()
        return

    # ---- CLI IMPORT MODE (source API disabled, parse CLI output) ----
    if args.cli_import:
        logger.info(f"CLI import mode: parsing {args.cli_import}")
        with open(args.cli_import, "r", errors="replace") as f:
            raw_cli = f.read()

        cli_parser = CLIConfigParser(raw_cli)
        config = cli_parser.parse_all()

        # Show what was parsed
        metadata = config.get("_metadata", {})
        logger.info(f"  Parsed: {metadata.get('source_model')} "
                    f"running {metadata.get('source_firmware')}")
        total_items = sum(len(v) for k, v in config.items()
                         if isinstance(v, list))
        logger.info(f"  Total objects parsed: {total_items}")

        # Check if API was disabled
        if "no enable" in raw_cli[raw_cli.find("sonicos-api"):raw_cli.find("sonicos-api")+200]:
            logger.warning("  NOTE: SonicOS API is DISABLED on this firewall.")
            logger.warning("  That's why we're using CLI parsing mode.")

        # Save parsed config as JSON backup
        backup_file = f"cli_parsed_{metadata.get('source_model', 'unknown').replace(' ', '_')}_{timestamp}.json"
        with open(backup_file, "w") as f:
            json.dump(config, f, indent=2, default=str)
        logger.info(f"  Parsed config saved to: {backup_file}")

        # Now connect to target and push
        if not target_info:
            target_info = gather_firewall_info("TARGET")
        if not skip_resources:
            skip_resources = select_resources()

        target = SonicWallAPI(**target_info, label="TARGET")
        if not target.login():
            logger.error("Cannot connect to target firewall. Aborting.")
            logger.info(f"Your parsed config is saved at: {backup_file}")
            sys.exit(1)

        try:
            migrator = SonicWallMigrator(
                source=None, target=target,
                dry_run=dry_run, skip_resources=skip_resources,
            )
            # Show confirmation
            print(f"\n{'!' * 70}")
            print(f"  About to import CLI-parsed configuration:")
            print(f"    FROM: {metadata.get('source_model')} "
                  f"({metadata.get('source_generation')})")
            print(f"    TO:   {target.host} ({target.generation}, {target.model})")
            if dry_run:
                print(f"    MODE: DRY RUN (no changes will be made)")
            else:
                print(f"    MODE: LIVE — changes WILL be applied!")
            print(f"{'!' * 70}")

            confirm = input("\n  Type 'YES' to proceed: ").strip()
            if confirm != "YES":
                logger.info("Migration cancelled by user.")
                logger.info(f"Your parsed config is saved at: {backup_file}")
                return

            migrator.import_all(config)
            migrator.print_summary()
        finally:
            target.logout()
        return

    # ---- NORMAL / EXPORT-ONLY MODE ----
    if not source_info:
        source_info = gather_firewall_info("SOURCE")

    if not args.export_only and not target_info:
        target_info = gather_firewall_info("TARGET")

    if not skip_resources:
        skip_resources = select_resources()

    # Connect to source
    source = SonicWallAPI(**source_info, label="SOURCE")
    if not source.login():
        logger.error("Cannot connect to source firewall. Aborting.")
        sys.exit(1)

    target = None
    try:
        # Export
        migrator = SonicWallMigrator(
            source=source, target=None,
            dry_run=dry_run, skip_resources=skip_resources,
        )
        config = migrator.export_all()

        # Save export to file
        backup_file = f"backup_{source.host.replace('.', '_')}_{timestamp}.json"
        with open(backup_file, "w") as f:
            json.dump(config, f, indent=2, default=str)
        logger.info(f"Configuration exported to: {backup_file}")

        if args.export_only:
            logger.info("Export-only mode — done.")
            migrator.print_summary()
            return

        # Connect to target and import
        target = SonicWallAPI(**target_info, label="TARGET")
        if not target.login():
            logger.error("Cannot connect to target firewall. Aborting.")
            logger.info(f"Your export is saved at: {backup_file}")
            sys.exit(1)

        migrator.target = target

        # --- Interface Migration Question ---
        interface_plan = None
        print(f"\n--- Interface Migration ---")

        if migrate_interfaces_flag is True:
            migrate_ifaces = "y"
            print("  Migrate interfaces and VLANs? [y/N]: y  (from config)")
        elif migrate_interfaces_flag is False:
            migrate_ifaces = "n"
            print("  Migrate interfaces and VLANs? [y/N]: n  (from config)")
        else:
            migrate_ifaces = input(
                "  Migrate interfaces and VLANs? [y/N]: "
            ).strip().lower()

        if migrate_ifaces in ("y", "yes"):
            comparison = migrator.compare_interfaces()
            interface_plan = migrator.select_interfaces_interactive(comparison)

        # Confirmation prompt
        print(f"\n{'!' * 70}")
        print(f"  About to migrate configuration:")
        print(f"    FROM: {source.host} ({source.generation}, {source.model})")
        print(f"    TO:   {target.host} ({target.generation}, {target.model})")
        if interface_plan and interface_plan["interfaces"]:
            n_iface = len(interface_plan["interfaces"])
            n_vlan = len(interface_plan["vlans"])
            print(f"    INTERFACES: {n_iface} interfaces + {n_vlan} VLANs selected")
        else:
            print(f"    INTERFACES: Not migrating (manual config)")
        if dry_run:
            print(f"    MODE: DRY RUN (no changes will be made)")
        else:
            print(f"    MODE: LIVE — changes WILL be applied!")
        print(f"{'!' * 70}")

        confirm = input("\n  Type 'YES' to proceed: ").strip()
        if confirm != "YES":
            logger.info("Migration cancelled by user.")
            logger.info(f"Your export is saved at: {backup_file}")
            return

        # Migrate interfaces first (before other resources that depend on them)
        if interface_plan and interface_plan["interfaces"]:
            migrator.migrate_interfaces(interface_plan)

        migrator.import_all(config)
        migrator.print_summary()

    finally:
        source.logout()
        if target:
            target.logout()


if __name__ == "__main__":
    main()
